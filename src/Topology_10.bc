import {
  Button,
  ColorPicker,
  Drawer,
  Input,
  message,
  Select,
  Switch,
} from "antd";
import * as d3 from "d3";
import dagre from "dagre";
import { graphlib } from "dagre-d3-es";
import { useEffect, useRef, useState } from "react";
import { chart_1212 } from "./chartData";
import "./topology.css";

const { Option } = Select;

function D3TopologyDiagram({ allAssets, backButtonHandler }) {
  const svgRef = useRef();
  const zoomToFitRef = useRef();
  const [nodes, setNodes] = useState([]);
  const [links, setLinks] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedAssetToAdd, setSelectedAssetToAdd] = useState(null);
  const [selectedNodeIds, setSelectedNodeIds] = useState([]);
  const [nextNodeIdToCreate, setNextNodeIdToCreate] = useState(0);
  const [isLayouting, setIsLayouting] = useState(false);

  const [groupName, setGroupName] = useState("");
  const [relationType, setRelationType] = useState("parent_child");
  const [groupColor, setGroupColor] = useState("#1677ff");

  const isDraggingRef = useRef(false);
  const nodePositionsRef = useRef(new Map());
  const initialLayoutDoneRef = useRef(false);
  const currentZoomRef = useRef(d3.zoomIdentity);

  const colors = {
    nodeBgNormal: "#e3f2fd",
    nodeBgSelected: "#edf2fb",
    nodeBorderNormal: "#1565C0",
    nodeBorderSelected: "#f00000",
    nodeTextColor: "#1e293b",
    nodeTextColorSelected: "#001d3d",
    groupChildBg: "#edf2fb",
    groupChildBorder: "#003566",
    groupChildContainerBg: "#caf0f8",
    groupChildContainerBorder: "#0077b6",
    groupChildText: "#000000",
    connectionPointBorderNormal: "#acadbc",
    connectionPointBgNormal: "#9b9ece",
    connectionPointBorderHover: "#fdc921",
    connectionPointBgHover: "#fdd85d",
    linkGreen: "#10b981",
    linkRed: "#ef4444",
    tempLink: "#94a3b8",
    arrowColor: "#000000",
  };

  const getNodeEdgePoint = (
    nodeX,
    nodeY,
    nodeWidth,
    nodeHeight,
    targetX,
    targetY
  ) => {
    const dx = targetX - nodeX;
    const dy = targetY - nodeY;

    // Calculate the slope
    const slope = Math.abs(dy / dx);
    const nodeAspect = nodeHeight / nodeWidth;

    let edgeX, edgeY;

    if (slope > nodeAspect) {
      // Intersection with top or bottom edge - use vertical center
      edgeX =
        nodeX +
        (dx > 0 ? nodeWidth / 2 : -nodeWidth / 2) * (nodeAspect / slope);
      edgeY = nodeY; // Always use vertical center
    } else {
      // Intersection with left or right edge - use vertical center
      edgeX = nodeX + (dx > 0 ? nodeWidth / 2 : -nodeWidth / 2);
      edgeY = nodeY; // Always use vertical center
    }

    return { x: edgeX, y: edgeY };
  };

  const handleZoomToFit = () => {
    const { positionedNodes } = computeLayout(nodes, links);
    setNodes((prev) =>
      prev.map((node) => {
        const pos = positionedNodes.find((p) => p.id === node.id);
        return pos ? { ...node, x: pos.x, y: pos.y } : node;
      })
    );
    nodePositionsRef.current = new Map(
      positionedNodes.map((n) => [
        n.id.toString(),
        { x: n.x, y: n.y, width: n.width, height: n.height },
      ])
    );
    initialLayoutDoneRef.current = true;
  };

  const addNode = () => {
    if (!selectedAssetToAdd) {
      message.error("Select a node first");
      return;
    }

    if (selectedNodeIds.length !== 1) return;

    const parentNode = nodes.find((n) => n.id === selectedNodeIds[0]);
    if (!parentNode || parentNode.type !== "node") return;

    const newNode = {
      id: nextNodeIdToCreate,
      name: selectedAssetToAdd,
      type: "node",
    };

    const newLink = {
      source: newNode,
      target: parentNode,
      relationType,
      id: `${newNode.id}-${parentNode.id}-${Date.now()}-${Math.random()}`,
    };

    setIsLayouting(true);

    setNodes((prev) => [...prev, newNode]);
    setLinks((prev) => [...prev, newLink]);

    setNextNodeIdToCreate(nextNodeIdToCreate + 1);
    setIsModalOpen(false);

    setTimeout(() => {
      handleZoomToFit();

      setTimeout(() => {
        setIsLayouting(false);
      }, 100);
    }, 50);
  };

  const getNodeWidth = (node) => {
    const len =
      node?.type === "group"
        ? Math.max(node?.name?.length, node?.groupName?.length)
        : node?.name?.length;

    return len * 8 + 20;
  };

  const getNodeHeight = (node) => {
    return 30;
  };

  const addGroupHandler = () => {
    if (groupName.length === 0) {
      alert("Give the group a name");
      return;
    }

    const groupNameIsUnique = !nodes.some(
      (n) =>
        n.groupName && n.groupName.toLowerCase() === groupName.toLowerCase()
    );

    if (!groupNameIsUnique) {
      
      alert("Group name already taken");
      return;
    }

    if (selectedNodeIds.length < 2) {
      alert("Select at least 2 nodes to create a group");
      return;
    }

    setNextNodeIdToCreate(nextNodeIdToCreate + 1);

    setNodes((prevNodes) =>
      prevNodes.map((node) => {
        if (selectedNodeIds.includes(node.id)) {
          return {
            ...node,
            type: "group",
            groupName,
            groupColor,
          };
        }
        return node;
      })
    );

    setGroupName("");
    setSelectedNodeIds([]);
    setTimeout(handleZoomToFit, 0);
  };

  const renameGroupHandler = () => {};
  const removeGroupHandler = () => {};

  const nodeDetailsHandler = () => {
    console.log(nodes);
  };

  const getRandomName = () => {
    const randomItem = allAssets[Math.floor(Math.random() * allAssets.length)];
    const name = randomItem.name || randomItem.value;
    return name;
  };

  const switchLinkHandler = () => {};

  const getBulkRandomNodes = (count) => {
    const nodes = [];
    let tempNextNodeId = nextNodeIdToCreate;

    for (let i = 0; i < count; i++) {
      const id = tempNextNodeId++;
      const name = getRandomName();

      nodes.push({ id, name, type: "node" });
    }

    setNextNodeIdToCreate(tempNextNodeId);
    return nodes;
  };

  const addBulkNodesHandler = async (count) => {
    if (selectedNodeIds.length !== 1) return;

    const parentNode = nodes.find((n) => n.id === selectedNodeIds[0]);
    if (!parentNode || parentNode.type !== "node") return;

    const newNodes = getBulkRandomNodes(count);
    const newLinks = newNodes.map((child) => ({
      source: child,
      target: parentNode,
      relationType,
      id: `${child.id}-${parentNode.id}-${Date.now()}-${Math.random()}`,
    }));

    setIsLayouting(true);

    setNodes((prev) => [...prev, ...newNodes]);
    setLinks((prev) => [...prev, ...newLinks]);

    setTimeout(() => {
      handleZoomToFit();

      setTimeout(() => {
        setIsLayouting(false);
      }, 100);
    }, 50);
  };

  const closeDrawer = () => {
    setIsModalOpen(false);
  };

  const changeSelectedAssetToAdd = (asset) => {
    setSelectedAssetToAdd(asset);
  };

  const handleToggle = (checked) => {
    setRelationType(checked ? "parent_child" : "interface");
  };

  const handleDeleteNode = () => {
    if (selectedNodeIds.length > 0) {
      setNodes((prev) =>
        prev.filter((node) => !selectedNodeIds.includes(node.id))
      );
      setLinks((prev) =>
        prev.filter(
          (link) =>
            !selectedNodeIds.includes(link.source.id) &&
            !selectedNodeIds.includes(link.target.id)
        )
      );
      setSelectedNodeIds([]);

      setTimeout(handleZoomToFit, 0);
    }
  };

  const computeLayout = (nodes, links) => {
    const g = new graphlib.Graph({ directed: true });

    g.setGraph({
      rankdir: "LR",
      align: "UL",
      ranksep: 100,
      nodesep: 40,
      marginx: 50,
      marginy: 50,
    });

    g.setDefaultEdgeLabel(() => ({}));

    nodes.forEach((node) => {
      const width = getNodeWidth(node);
      const height = getNodeHeight(node);
      g.setNode(node.id.toString(), { width, height });
    });

    links.forEach((link) => {
      g.setEdge(link.target.id.toString(), link.source.id.toString());
    });

    dagre.layout(g);

    const positionedNodes = nodes.map((node) => {
      const n = g.node(node.id.toString());
      return {
        ...node,
        x: n.x,
        y: n.y,
        width: n.width,
        height: n.height,
      };
    });

    const positionedLinks = links.map((link) => {
      const edge = g.edge(link.target.id.toString(), link.source.id.toString());
      return {
        ...link,
        points: edge.points,
      };
    });

    return { positionedNodes, positionedLinks };
  };

  const getNodePositionFromDOM = (nodeId, inner) => {
    const nodeElement = inner.select(`g.node[id="${nodeId}"]`);
    if (nodeElement.empty()) return null;
    const transform = nodeElement.attr("transform");
    if (transform) {
      const match = transform.match(/translate\(([^,]+),([^)]+)\)/);
      if (match) {
        return {
          x: parseFloat(match[1]),
          y: parseFloat(match[2]),
        };
      }
    }
    return null;
  };

  const updateEdgeDuringDrag = (
    sourceId,
    targetId,
    sourceX,
    sourceY,
    targetX,
    targetY,
    inner
  ) => {
    const edgeElement = inner.select(
      `g.edgePath[data-source="${sourceId}"][data-target="${targetId}"]`
    );
    if (!edgeElement.empty()) {
      // Get node dimensions from ref
      const sourceNode = nodePositionsRef.current.get(sourceId);
      const targetNode = nodePositionsRef.current.get(targetId);

      if (sourceNode && targetNode) {
        // Calculate edge start and end points
        const startPoint = getNodeEdgePoint(
          sourceX,
          sourceY,
          sourceNode.width,
          sourceNode.height,
          targetX,
          targetY
        );

        const endPoint = getNodeEdgePoint(
          targetX,
          targetY,
          targetNode.width,
          targetNode.height,
          sourceX,
          sourceY
        );

        const midX = (startPoint.x + endPoint.x) / 2;
        const path = `M${startPoint.x},${startPoint.y} H${midX} V${endPoint.y} H${endPoint.x}`;
        edgeElement.select("path").attr("d", path);

        const pathNode = edgeElement.select("path").node();
        if (pathNode) {
          const totalLength = pathNode.getTotalLength();
          if (totalLength > 20) {
            // Add gap to prevent arrow from being covered
            const gap = 8;
            const endPoint = pathNode.getPointAtLength(totalLength - gap);
            const anglePoint = pathNode.getPointAtLength(
              totalLength - gap - 10
            );
            const angle =
              Math.atan2(endPoint.y - anglePoint.y, endPoint.x - anglePoint.x) *
              (180 / Math.PI);
            const flippedAngle = angle;
            const playButton = edgeElement.select(".play-button-marker");
            playButton.attr(
              "transform",
              `translate(${endPoint.x}, ${endPoint.y}) rotate(${flippedAngle})`
            );
          }
        }
      }
    }
  };

  const setupDrag = (inner, nodeLevels, rootNodes) => {
    const drag = d3
      .drag()
      .on("start", function (event, d) {
        isDraggingRef.current = true;
        const nodeGroup = d3.select(this);
        nodeGroup.raise();

        const transform = nodeGroup.attr("transform");
        if (transform) {
          const match = transform.match(/translate\(([^,]+),([^)]+)\)/);
          if (match) {
            nodePositionsRef.current.set(d.id.toString(), {
              x: parseFloat(match[1]),
              y: parseFloat(match[2]),
              width: d.width || getNodeWidth(d),
              height: d.height || getNodeHeight(d),
            });
          }
        }
      })
      .on("drag", function (event, d) {
        if (!isDraggingRef.current) return;

        const currentPos = nodePositionsRef.current.get(d.id.toString()) || {
          x: 0,
          y: 0,
        };
        const newX = currentPos.x + event.dx;
        const newY = currentPos.y + event.dy;

        nodePositionsRef.current.set(d.id.toString(), {
          x: newX,
          y: newY,
          width: currentPos.width,
          height: currentPos.height,
        });
        d3.select(this).attr("transform", `translate(${newX}, ${newY})`);

        const connectedLinks = links.filter(
          (link) => link.source.id === d.id || link.target.id === d.id
        );

        connectedLinks.forEach((link) => {
          const sourceId = link.source.id.toString();
          const targetId = link.target.id.toString();
          let sourcePos, targetPos;
          let sourceDims, targetDims;

          if (sourceId === d.id.toString()) {
            sourcePos = { x: newX, y: newY };
            sourceDims = nodePositionsRef.current.get(sourceId);
            targetPos =
              nodePositionsRef.current.get(targetId) ||
              getNodePositionFromDOM(targetId, inner);
            targetDims = nodePositionsRef.current.get(targetId);
          } else {
            sourcePos =
              nodePositionsRef.current.get(sourceId) ||
              getNodePositionFromDOM(sourceId, inner);
            sourceDims = nodePositionsRef.current.get(sourceId);
            targetPos = { x: newX, y: newY };
            targetDims = nodePositionsRef.current.get(targetId);
          }

          if (sourcePos && targetPos && sourceDims && targetDims) {
            updateEdgeDuringDrag(
              sourceId,
              targetId,
              sourcePos.x,
              sourcePos.y,
              targetPos.x,
              targetPos.y,
              inner
            );
          }
        });
      })
      .on("end", function (event, d) {
        isDraggingRef.current = false;

        const finalPos = nodePositionsRef.current.get(d.id.toString());
        if (finalPos) {
          setNodes((prev) =>
            prev.map((node) =>
              node.id === d.id
                ? { ...node, x: finalPos.x, y: finalPos.y }
                : node
            )
          );
        }

        const wasClick =
          Math.abs(event.sourceEvent.movementX) < 2 &&
          Math.abs(event.sourceEvent.movementY) < 2;

        if (wasClick) {
          const clickedNodeId = d.id;

          if (event.sourceEvent.shiftKey) {
            setSelectedNodeIds((prev) => {
              if (selectedNodeIds.length > 0) {
                const lastSelectedType = nodes.find(
                  (n) => n.id === selectedNodeIds[selectedNodeIds.length - 1]
                ).type;
                const currentSelectedType = nodes.find(
                  (n) => n.id === clickedNodeId
                ).type;
                if (
                  lastSelectedType !== currentSelectedType ||
                  lastSelectedType === "group"
                ) {
                  return [clickedNodeId];
                }
              }

              if (prev.includes(clickedNodeId)) {
                return prev.filter((id) => id !== clickedNodeId);
              } else {
                return [...prev, clickedNodeId];
              }
            });
          } else {
            setSelectedNodeIds([clickedNodeId]);
          }
        }
      });

    inner.selectAll("g.node").call(drag);
  };

  const draw = () => {
    const childrenMap = {};
    const parentMap = {};

    links.forEach((link) => {
      const parentId = link.target.id;
      const childId = link.source.id;

      if (!childrenMap[parentId]) childrenMap[parentId] = [];
      if (!parentMap[childId]) parentMap[childId] = [];

      childrenMap[parentId].push(childId);
      parentMap[childId].push(parentId);
    });

    const rootNodes = nodes.filter((node) => !parentMap[node.id]);

    const nodeLevels = {};
    const processedNodes = new Set();

    const assignLevels = (nodeId, level) => {
      if (nodeLevels[nodeId] !== undefined && nodeLevels[nodeId] >= level)
        return;

      nodeLevels[nodeId] = level;
      processedNodes.add(nodeId);

      const children = childrenMap[nodeId] || [];
      children.forEach((childId) => {
        assignLevels(childId, level + 1);
      });
    };

    rootNodes.forEach((root) => {
      assignLevels(root.id, 0);
    });

    nodes.forEach((node) => {
      if (!processedNodes.has(node.id)) {
        nodeLevels[node.id] = nodes.length;
      }
    });

    const svg = d3.select(svgRef.current);
    const inner = svg.select("g");

    inner.selectAll("*").remove();

    const hasManualPositions = nodes.every(
      (n) => n.x !== undefined && n.y !== undefined
    );

    let positionedNodes, positionedLinks;

    if (!initialLayoutDoneRef.current || !hasManualPositions) {
      ({ positionedNodes, positionedLinks } = computeLayout(nodes, links));
      positionedNodes.forEach((n) =>
        nodePositionsRef.current.set(n.id.toString(), {
          x: n.x,
          y: n.y,
          width: n.width,
          height: n.height,
        })
      );
      initialLayoutDoneRef.current = true;
      setNodes((prev) =>
        prev.map((node, i) => ({
          ...node,
          x: positionedNodes[i]?.x || 0,
          y: positionedNodes[i]?.y || 0,
        }))
      );
      return;
    } else {
      positionedNodes = nodes.map((n) => ({
        ...n,
        width: getNodeWidth(n),
        height: getNodeHeight(n),
      }));
      positionedLinks = links.map((l) => {
        const sourcePos = nodePositionsRef.current.get(
          l.source.id.toString()
        ) || { x: l.source.x || 0, y: l.source.y || 0 };
        const targetPos = nodePositionsRef.current.get(
          l.target.id.toString()
        ) || { x: l.target.x || 0, y: l.target.y || 0 };

        const sourceDims = nodePositionsRef.current.get(
          l.source.id.toString()
        ) || {
          width: getNodeWidth(l.source),
          height: getNodeHeight(l.source),
        };
        const targetDims = nodePositionsRef.current.get(
          l.target.id.toString()
        ) || {
          width: getNodeWidth(l.target),
          height: getNodeHeight(l.target),
        };

        // Calculate edge start and end points from node edges
        const startPoint = getNodeEdgePoint(
          sourcePos.x,
          sourcePos.y,
          sourceDims.width,
          sourceDims.height,
          targetPos.x,
          targetPos.y
        );

        const endPoint = getNodeEdgePoint(
          targetPos.x,
          targetPos.y,
          targetDims.width,
          targetDims.height,
          sourcePos.x,
          sourcePos.y
        );

        const midX = (startPoint.x + endPoint.x) / 2;
        const points = [
          { x: startPoint.x, y: startPoint.y },
          { x: midX, y: startPoint.y },
          { x: midX, y: endPoint.y },
          { x: endPoint.x, y: endPoint.y },
        ];
        return { ...l, points };
      });
    }

    const edgeGroups = inner
      .selectAll("g.edgePath")
      .data(positionedLinks)
      .enter()
      .append("g")
      .attr("class", "edgePath")
      .attr("data-source", (d) => d.source.id.toString())
      .attr("data-target", (d) => d.target.id.toString());

    edgeGroups
      .append("path")
      .attr("d", (d) => {
        const lineGenerator = d3
          .line()
          .x((p) => p.x)
          .y((p) => p.y)
          .curve(d3.curveLinear);
        return lineGenerator(d.points);
      })
      .style("stroke", "#666")
      .style("fill", "none")
      .style("stroke-width", "2px")
      .style("stroke-linecap", "round")
      .style("stroke-linejoin", "round");

    edgeGroups.each(function (d) {
      const edge = d3.select(this);
      const pathNode = edge.select("path").node();
      if (pathNode) {
        const totalLength = pathNode.getTotalLength();
        if (totalLength > 20) {
          // Add gap to prevent arrow from being covered
          const gap = 8;
          const endPoint = pathNode.getPointAtLength(totalLength - gap);
          const anglePoint = pathNode.getPointAtLength(totalLength - gap - 10);
          const angle =
            Math.atan2(endPoint.y - anglePoint.y, endPoint.x - anglePoint.x) *
            (180 / Math.PI);
          const flippedAngle = angle;
          const playButtonGroup = edge
            .append("g")
            .attr("class", "play-button-marker")
            .attr(
              "transform",
              `translate(${endPoint.x}, ${endPoint.y}) rotate(${flippedAngle})`
            );
          playButtonGroup
            .append("path")
            .attr("d", "M0,-8 L12,0 L0,8 Z")
            .style("fill", "#000000")
            .style("stroke", "#000000")
            .style("stroke-width", "1px");
        }
      }
    });

    const nodeGroups = inner
      .selectAll("g.node")
      .data(positionedNodes)
      .enter()
      .append("g")
      .attr("class", "node")
      .attr("id", (d) => d.id.toString())
      .attr("transform", (d) => `translate(${d.x}, ${d.y})`);

    nodeGroups.each(function (d) {
      const nodeGroup = d3.select(this);
      const level = nodeLevels[d.id] || 0;
      const isRoot = rootNodes.some((root) => root.id === d.id);

      let nodeStyle, labelColor;

      if (selectedNodeIds.includes(d.id)) {
        nodeStyle = {
          fill: colors.nodeBgSelected,
          stroke: colors.nodeBorderSelected,
          strokeWidth: "3px",
        };
        labelColor = colors.nodeTextColorSelected;
      } else if (isRoot) {
        nodeStyle = {
          fill: "#4CAF50",
          stroke: "#2E7D32",
          strokeWidth: "3px",
        };
        labelColor = "#fff";
      } else if (level === 1) {
        nodeStyle = {
          fill: "#2196F3",
          stroke: "#0D47A1",
          strokeWidth: "2px",
        };
        labelColor = "#fff";
      } else {
        nodeStyle = {
          fill: colors.nodeBgNormal,
          stroke: colors.nodeBorderNormal,
          strokeWidth: "2px",
        };
        labelColor = "#333";
      }

      if (d.type === "group") {
        const topHalfHeight = d.height / 2;
        const bottomHalfHeight = d.height / 2;

        nodeGroup
          .append("rect")
          .attr("class", "node-border")
          .attr("width", d.width)
          .attr("height", d.height)
          .attr("x", -d.width / 2)
          .attr("y", -d.height / 2)
          .attr("rx", 5)
          .attr("ry", 5)
          .style("fill", nodeStyle.fill)
          .style("stroke", nodeStyle.stroke)
          .style("stroke-width", nodeStyle.strokeWidth);

        const clipId = `clip-top-${d.id}`;

        const clipPath = nodeGroup.append("clipPath").attr("id", clipId);

        const x = -d.width / 2 + 1;
        const y = -d.height / 2 + 1;
        const width = d.width - 2;
        const height = topHalfHeight;
        const radius = 4;

        clipPath.append("path").attr(
          "d",
          `
            M ${x}, ${y + radius}
            A ${radius} ${radius} 0 0 1 ${x + radius}, ${y}
            L ${x + width - radius}, ${y}
            A ${radius} ${radius} 0 0 1 ${x + width}, ${y + radius}
            L ${x + width}, ${y + height}
            L ${x}, ${y + height}
            Z
          `
        );

        nodeGroup
          .append("rect")
          .attr("width", d.width)
          .attr("height", topHalfHeight)
          .attr("x", -d.width / 2)
          .attr("y", -d.height / 2)
          .style("fill", d.groupColor)
          .style("stroke", "none")
          .attr("clip-path", `url(#${clipId})`);

        nodeGroup
          .append("text")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("y", -d.height / 2 + topHalfHeight / 2)
          .style("font-size", "12px")
          .style("font-weight", "bold")
          .style("font-family", "sans-serif")
          .style("fill", "#fff")
          .text(d.groupName);

        nodeGroup
          .append("text")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("y", -d.height / 2 + topHalfHeight + bottomHalfHeight / 2)
          .style("font-size", "12px")
          .style("font-weight", "bold")
          .style("font-family", "sans-serif")
          .style("fill", labelColor)
          .text(d.name);
      } else {
        nodeGroup
          .append("rect")
          .attr("class", "node-border")
          .attr("width", d.width)
          .attr("height", d.height)
          .attr("x", -d.width / 2)
          .attr("y", -d.height / 2)
          .attr("rx", 5)
          .attr("ry", 5)
          .style("fill", nodeStyle.fill)
          .style("stroke", nodeStyle.stroke)
          .style("stroke-width", nodeStyle.strokeWidth);

        nodeGroup
          .append("text")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .style("font-size", "14px")
          .style("font-weight", "bold")
          .style("font-family", "sans-serif")
          .style("fill", labelColor)
          .text(d.name);
      }
    });

    nodeGroups.append("title").text((d) => {
      const level = nodeLevels[d.id] || 0;
      const isRoot = rootNodes.some((root) => root.id === d.id);
      const nodeType = isRoot ? "Root/Parent" : `Child (Level ${level})`;
      return `${d?.asset_equipdesc || d.id}\nID: ${d.id}\nType: ${nodeType}`;
    });

    nodeGroups
      .on("mouseover", function (event, d) {
        d3.select(this)
          .select(".node-border")
          .style("stroke", colors.nodeBorderSelected)
          .style("stroke-width", "4px");
      })
      .on("mouseout", function (event, d) {
        const level = nodeLevels[d.id] || 0;
        const isRoot = rootNodes.some((root) => root.id === d.id);

        let strokeColor, strokeWidth;
        if (selectedNodeIds.includes(d.id)) {
          strokeColor = colors.nodeBorderSelected;
          strokeWidth = "3px";
        } else if (isRoot) {
          strokeColor = "#2E7D32";
          strokeWidth = "3px";
        } else if (level === 1) {
          strokeColor = "#0D47A1";
          strokeWidth = "2px";
        } else {
          strokeColor = colors.nodeBorderNormal;
          strokeWidth = "2px";
        }

        d3.select(this)
          .select(".node-border")
          .style("stroke", strokeColor)
          .style("stroke-width", strokeWidth);
      });

    edgeGroups
      .on("mouseover", function (event, d) {
        d3.select(this)
          .select("path")
          .style("stroke", colors.nodeBorderSelected)
          .style("stroke-width", "3px");

        d3.select(this)
          .select(".play-button-marker path")
          .style("fill", "#333")
          .style("stroke", "#333");
      })
      .on("mouseout", function (event, d) {
        d3.select(this)
          .select("path")
          .style("stroke", "#666")
          .style("stroke-width", "2px");

        d3.select(this)
          .select(".play-button-marker path")
          .style("fill", "#000000")
          .style("stroke", "#000000");
      });

    setupDrag(inner, nodeLevels, rootNodes);

    // ZOOM: Cache user zoom
    const zoom = d3
      .zoom()
      .scaleExtent([0.1, 2])
      .on("zoom", (event) => {
        inner.attr("transform", event.transform);
        currentZoomRef.current = event.transform; // Save user zoom
      });

    svg.call(zoom);
    svg.call(zoom.transform, currentZoomRef.current);

    svg.on("click", (event) => {
      if (!event.target.closest("g.node")) {
        setSelectedNodeIds([]);
      }
    });

    // Zoom-to-fit function â€” only called by button
    const zoomToFit = () => {
      const bounds = inner.node().getBBox();
      const parent = svg.node().parentElement;
      const fullWidth = parent.clientWidth;
      const fullHeight = parent.clientHeight;

      if (bounds.width > 0 && bounds.height > 0) {
        const scale = Math.min(
          0.85,
          0.85 / Math.max(bounds.width / fullWidth, bounds.height / fullHeight)
        );
        const translate = [
          (fullWidth - bounds.width * scale) / 2 - bounds.x * scale,
          (fullHeight - bounds.height * scale) / 2 - bounds.y * scale,
        ];

        const newTransform = d3.zoomIdentity
          .translate(translate[0], translate[1])
          .scale(scale);

        currentZoomRef.current = newTransform; // Update cache
        svg.call(zoom.transform, newTransform);
      }
    };
    zoomToFitRef.current = zoomToFit;
  };

  const handleZoomToFitClick = () => {
    handleZoomToFit();
    setTimeout(() => {
      if (zoomToFitRef.current) zoomToFitRef.current();
    }, 100);
  };

  const parseNetworkChartData = (chartData) => {
    const allNodes = Array.from(
      new Map(
        chartData.relationships
          .filter((n) => n.relationship_type === 0)
          .map((item) => [
            item.this_asset_id,
            {
              id: item.this_asset_id,
              type: "node",
              x: parseFloat(item?.x || "0") || 0,
              y: parseFloat(item?.y || "0") || 0,
              name: " " + item.this_asset_id + " ",
              asset_equipdesc: item.this.asset_equipdesc,
              criticality: item.criticality,
            },
          ])
      ).values()
    );

    const allParentChildRelations = chartData.relationships
      .filter((n) => n.relationship_type === 1)
      .map((item) => ({
        source: allNodes.find((n) => n.id === item.this_asset_id),
        target: allNodes.find((n) => n.id === item.other_asset_id),
        relationType: "parent_child",
      }))
      .filter((r) => r.source && r.target);

    const allInterfaceRelations = chartData.relationships
      .filter((n) => n.relationship_type === 2)
      .map((item) => ({
        source: allNodes.find((n) => n.id === item.this_asset_id),
        target: allNodes.find((n) => n.id === item.other_asset_id),
        relationType: "interface",
      }))
      .filter((r) => r.source && r.target);

    return {
      allNodes: allNodes,
      allLinks: [...allParentChildRelations, ...allInterfaceRelations],
    };
  };

  const loadChartData = async () => {
    try {
      const response = chart_1212;
      const chartData = parseNetworkChartData(response);

      setNodes(chartData.allNodes);
      setLinks(chartData.allLinks);
      setNextNodeIdToCreate(nextNodeIdToCreate + 1);

      initialLayoutDoneRef.current = false;
    } catch (error) {
      console.log(error);
    }
  };

  useEffect(() => {
    if (!svgRef.current || isDraggingRef.current || isLayouting) {
      return;
    }
    draw();
  }, [nodes, links, isLayouting, selectedNodeIds]);

  useEffect(() => {
    if (nodes.length === 0) {
      loadChartData();
    }
  }, []);

  return (
    <div className="topology-container" style={{ padding: "10px" }}>
      <div className="topology-top-nav">
        <Input
          className="btn"
          value={groupName}
          placeholder="Please input Group name"
          onChange={(e) => setGroupName(e.target.value)}
          style={{ minWidth: "120px", maxWidth: "160px" }}
        />
        <div
          style={{ display: "flex", alignItems: "center", marginRight: "4px" }}
        >
          <ColorPicker
            value={groupColor}
            onChange={(color) => setGroupColor(color.toHexString())}
            size="large"
          />
        </div>
        <Button
          className="btn"
          type="primary"
          onClick={addGroupHandler}
          disabled={selectedNodeIds.length < 2}
        >
          Add Group
        </Button>
        <Button
          className="btn"
          type="primary"
          onClick={renameGroupHandler}
          disabled={
            groupName.length < 3 ||
            selectedNodeIds.length !== 1 ||
            nodes.find((n) => n.id === selectedNodeIds[0])?.type !== "group"
          }
        >
          Rename Group
        </Button>
        <Button
          className="btn"
          type="primary"
          onClick={removeGroupHandler}
          disabled={
            groupName.length < 3 ||
            selectedNodeIds.length !== 1 ||
            nodes.find((n) => n.id === selectedNodeIds[0])?.type !== "group"
          }
        >
          Remove Group
        </Button>
        <Button
          className="btn"
          type="primary"
          onClick={() => setIsModalOpen(true)}
        >
          Add Node
        </Button>

        <Button
          className="btn"
          type="primary"
          onClick={nodeDetailsHandler}
          disabled={
            selectedNodeIds.length !== 1 ||
            nodes.find((n) => n.id === selectedNodeIds[0])?.type !== "node"
          }
        >
          Node Details
        </Button>
        <Button className="btn" type="primary" onClick={switchLinkHandler}>
          Switch Link
        </Button>

        <Button className="btn" type="primary" onClick={handleZoomToFitClick}>
          Center The Chart
        </Button>

        <Button
          onClick={handleDeleteNode}
          className={"btn"}
          disabled={selectedNodeIds.length === 0}
          style={{
            backgroundColor:
              selectedNodeIds.length > 0
                ? colors.nodeBorderSelected
                : "#9ca3af",
            borderRadius: "0px",
            color: "white",
          }}
        >
          Delete Node
        </Button>
        <div
          style={{
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            background: "#fff",
            padding: "0px 10px",
            height: "36px",
          }}
        >
          <Switch
            checkedChildren="Parent/Child"
            unCheckedChildren="Interface"
            checked={relationType === "parent_child"}
            onChange={handleToggle}
            style={{
              backgroundColor:
                relationType === "parent_child" ? "green" : "red",
              borderColor: relationType === "parent_child" ? "green" : "red",
            }}
          />
        </div>

        <Button
          className="btn"
          onClick={() => addBulkNodesHandler(2)}
          disabled={
            selectedNodeIds.length !== 1 ||
            nodes.find((n) => n.id === selectedNodeIds[0])?.type !== "node"
          }
        >
          Add 2 Nodes
        </Button>
        <Button
          className="btn"
          onClick={() => addBulkNodesHandler(5)}
          disabled={
            selectedNodeIds.length !== 1 ||
            nodes.find((n) => n.id === selectedNodeIds[0])?.type !== "node"
          }
        >
          Add 5 Nodes
        </Button>
        <Button
          className="btn"
          onClick={() => addBulkNodesHandler(100)}
          disabled={
            selectedNodeIds.length !== 1 ||
            nodes.find((n) => n.id === selectedNodeIds[0])?.type !== "node"
          }
        >
          Add 100 Nodes
        </Button>
        <Button
          className="btn"
          onClick={() => addBulkNodesHandler(200)}
          disabled={
            selectedNodeIds.length !== 1 ||
            nodes.find((n) => n.id === selectedNodeIds[0])?.type !== "node"
          }
        >
          Add 200 Nodes
        </Button>
        <Button className="btn" onClick={backButtonHandler}>
          Back
        </Button>

        <div
          style={{
            fontWeight: "bold",
            fontSize: "20px",
            padding: "0px 20px",
            display: "flex",
            alignItems: "center",
          }}
        >
          Total Nodes: {nodes.length}
        </div>
      </div>

      <svg
        ref={svgRef}
        width="100%"
        height="calc(100vh - 130px)"
        style={{
          border: "1px solid #ccc",
          marginTop: 10,
          background: "#fafafa",
        }}
      >
        <g />
      </svg>

      <Drawer
        title="Settings"
        placement="left"
        onClose={closeDrawer}
        open={isModalOpen}
        width={300}
      >
        <div style={{ display: "flex", flexDirection: "column", gap: "10px" }}>
          <h3>Add Node</h3>
          <p>Select an asset:</p>
          <Select
            placeholder="Choose one"
            style={{ width: "100%" }}
            value={selectedAssetToAdd}
            onChange={changeSelectedAssetToAdd}
          >
            {allAssets.map((a, i) => (
              <Option key={i} value={a.name}>
                {a.name}
              </Option>
            ))}
          </Select>

          <div style={{ textAlign: "right", marginTop: "20px" }}>
            <Button type="text" onClick={() => setIsModalOpen(false)}>
              Cancel
            </Button>
            <Button
              type="primary"
              disabled={!selectedAssetToAdd}
              onClick={addNode}
              style={{ marginLeft: 8 }}
            >
              OK
            </Button>
          </div>
        </div>
      </Drawer>
    </div>
  );
}

export default D3TopologyDiagram;
